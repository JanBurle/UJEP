# 04 – Indexy a analýza dotazů

[PostgreSQL Ch.11](https://www.postgresql.org/docs/current/indexes.html)

## Indexy:

Výhody:

- zajistí referenční integritu (PK, unique)
- urychlí vyhledávaní záznamů (řádek) pro: `select`, `update`, `delete` (`where`), `join`

Nevýhody:

- data navíc (v lepším případě podmnožina dat): zvýší režii (náklady na běh, overhead) databáze – index je nutno vytvořit a udržovat, podobně jako index na konci knihy.

Např. při selekci řádků (`select ... where ...`) bez indexů je nutné projít (scan) celou tabulku (v čase _O(n)_). Pokud ale existuje odpovídají index nad poli použitými v klauzuli `where ...`, lze záznamy vyhledat rychleji, typicky pomocí vyhledávacího stromu (search tree), v čase _O(log n)_.

Podobné urychlení nastane při spojování (`join`) a řazení (`order by`).

Je nutné zvážit:

- kompromis prostor / čas
- indexy udržovat nebo jen dočasně vytvořit a smazat (`drop`) ?

### Typy indexů

#### [B-stromy](https://cs.wikipedia.org/wiki/B-strom) (default)

```sql
create index name on table(column);
```

Vhodné pro:

- porovnávání `<`, `<=`, `=`, `>=`, `>`, `between`, `in`, `is (not) null`, `like 'xxx%'`
- řazení `order by`

#### [Haš](https://cs.wikipedia.org/wiki/Ha%C5%A1ovac%C3%AD_funkce)

Založený na hašovacích tabulkách.

```sql
create index name on table using hash (column);
```

- nižší režie než B-stromy
- vhodné jen pro `=`

#### GIST, SP-GIST (Geographic Information Systems Technology)

- pro prostorové souřadnice, hledání sousedů
- používají [quadtree](https://en.wikipedia.org/wiki/Quadtree) (2D) nebo [octtree](https://en.wikipedia.org/wiki/Octree) (3D)

#### GIN (Generalized INverted index)

Fulltext search, `like`, apod.

[Pro zvídavé](https://pganalyze.com/blog/gin-index)

### Indexy nad více sloupci (multicolumn, vícesloupcové)

```sql
create index name on table(col1, col2, ...);
create index name on table(col1 desc, col2 nulls first/last, ...);
```

Nejvíce rozlišující sloupec by měl být uveden první zleva, pak druhý nejvíce rozlišující, atd.

Vhodné pro dotazy typu

```sql
... where col1 op ... and col2 op ... and ...);
```

a

```sql
... order by col1, col2, ...);
```

(zleva doprava: col1, col2, ...)

### Kombinace indexů

Při `and` databáze může použít jen jeden index:

```sql
... where ... and ...;
```

`or` vyžaduje více indexů (nebo jeden index vícekrát):

```sql
... where ... or ...;
```

### Unikátní indexy

```sql
create unique index name on ... [ nulls [ not ] distinct ];
```

### Indexy nad výrazy (vypočítané indexy)

Pokud je v např. dotazech funkce:

```sql
... where lower(col) = 'value';
```

pak je užitečný odpovídající index:

```sql
create index name on table(lower(col));
```

Nebo, jestliže dotaz je:

```sql
select * from people where (first_name || ' ' || last_name) = 'john smith';
```

bude užitečný index

```sql
create index names on people ((first_name || ' ' || last_name));
```

### Částečné indexy (partial indexes)

Kompromis mezi režií přípravy a zrychlením provádění dotazů. Indexují jen určitý rozsah hodnot:

```sql
create index name on table(col) where ... col ...
```

### Dotazy jen nad indexy

Pokud dotaz používá jen sloupce, které jsou v indexu, nemusí se číst tabulka, ale stačí jen index:

```sql
create index name on table(col1, col2, ...)
```

```sql
select col1, col2 from name where ... col1 ... col2 ...
```

## Optimalizace dotazů

Heuristické metody výběru optimálního způsobu provedení dotazu (optimalizace) v DBS závisí na velikosti zpracovávaných tabulek, včetně dočasných tabulek vzniklých během provádění složitějších dotazů. Velikost tabulky je dána především počtem řádků (počet zpracovávaných sloupců bývá v praxi omezený):

1. microtabulky = tabulky s několika málo řádky a sloupci, desítky až stovky

- optimalizace je kontraproduktivní, seq scan, podle potřeby hash join

2. mezotabulky = desítky až tisíce řádků (jeden nebo několik diskových bloků / resp. stránek paměti)

- bitmap scan při více filtrech, hash join, merge join

3. macrotabulky = statisíce a více řádků

- index scan, merge join, partitioning, pomocné tabulky, materialized views

## Prováděcí plán

Plánovač v DBS připraví tzv. prováděcí plán dotazu. To je kritická operace. Rozhoduje se mj. podle velikosti tabulek. Rozsah průběžně vytvářených tabulek lze předem určit jen obtížně (výjimka: agregace, dotazy se sekcí `limit`), proto se běžně jen odhaduje:

- z velikosti fyzických tabulek
- z empiricky zjištěných rozdělení pravděpodobnosti
- z výsledků předchozích obdobných dotazů

Dobré odhady vyžadují průběžnou analýzu dat a provádění reálně využívaných dotazů (tzv. postupná akomodace).

## Analýza dotazů

Jak se zjistí jaký plán byl použit:

```sql
explain [analyze] dotaz
```

Vypíše detailní plán s uvedením použitých mechanismů, odhadovanou cenou a počtem řádků tabulek.

(`analyze` = vykoná plán a údaje o reálném provedení přidá do výstupu pro srovnání.)

`explain` zobrazí plán.

## Praktický příklad

Dvě verze tabulek:

1. Nejdřív [tabulky bez indexů](../projekt/initX/1%20-%20schema-noPK.sql)
2. Pak [tabulky s PK/FK](../projekt/initX/1%20-%20schema.sql)

Prozkoumejte:

```sql
select count(*) from country;
explain select count(*) from country;
explain analyze select count(*) from country;
```

```sql
select count(*) from country where code='OO';
explain select count(*) from country where code='OO';
explain analyze select count(*) from country where code='OO';
```

```sql
select count(*) from country cross join place;
explain select count(*) from country cross join place;
explain analyze select count(*) from country cross join place;
```

```sql
select count(*) from country join place on code=code_country;
explain select count(*) from country join place on code=code_country;
explain analyze select count(*) from country join place on code=code_country;
```

```sql
select count(*) from place join weather on place.id=weather.id_place;
explain select count(*) from place join weather on place.id=weather.id_place;
explain analyze select count(*) from place join weather on place.id=weather.id_place;
```

```sql
select count(*) from city join weather on city.id=weather.city_id where city.id='oo';
explain select count(*) from city join weather on city.id=weather.city_id where city.id='oo';
explain analyze select id from city join weather on city.id=weather.city_id where city.id='oo';
vacuum analyze;
```

```sql
drop index if exists idx_temp_lo;
create index idx_temp_lo on weather(temp_lo);

explain analyze select avg(temp_lo) from weather where temp_lo < 20;

explain analyze select temp_hi from weather where temp_lo < 20;
explain analyze select temp_lo from weather where temp_hi < 20;

explain analyze select temp_hi from weather order by temp_lo;
explain analyze select temp_lo from weather order by temp_lo;
explain analyze select temp_lo from weather order by temp_hi;
```

continent → country → place → weather

> For each continent, what is the average daily maximum temperature and total precipitation over the last year, only for places above 1000 meters elevation, and show the top 5 hottest continents?

```sql
explain analyze
select
  c.name                   as continent,
  round(avg(w.temp_hi), 1) as avg_temp_hi,
  round(sum(w.precip), 1)  as total_precip
from weather w
  join place     p on p.id   = w.id_place
  join country   y on y.code = p.code_country
  join continent c on c.id   = y.id_continent
where p.elevation > 1000
  and current_date - interval '1 year' <= w.date
group by c.name
order by avg_temp_hi desc
limit 5;

-- filters
create index idx_weather_date on weather(date);
create index idx_place_elevation on place(elevation);

-- joins
create index idx_weather_id_place on weather(id_place);
create index idx_place_code_country on place(code_country);
create index idx_country_id_continent on country(id_continent);

```

```sql
create materialized view mv_weather_summary as
select
    w.id_place,
    date_trunc('month', w.date) as month,
    avg(w.temp_hi) as avg_hi,
    sum(w.precip) as total_precip
from weather w
group by w.id_place, date_trunc('month', w.date);

-- refresh materialized view mv_weather_summary;

select
    c.name as continent,
    round(avg(mv.avg_hi), 1)       as avg_temp_hi,
    round(sum(mv.total_precip), 1) as total_precip
from mv_weather_summary mv
join place     p on p.id   = mv.id_place
join country   y on y.code = p.code_country
join continent c on c.id   = y.id_continent
where p.elevation > 1000
  and date_trunc('month', current_date - interval '1 year') <= mv.month
group by c.name
order by avg_temp_hi desc
limit 5;
```
