# 02 – Spojení, agregace, pohledy.

- _[Postgres dokumentace Ch.2](https://www.postgresql.org/docs/17/tutorial-sql.html)_
- _[Postgres dokumentace Ch.3](https://www.postgresql.org/docs/17/tutorial-advanced.html)_

## Databáze

Použijeme poslední model a data z [01b](./01b.md).

### Příklady `select`

```sql
-- počasí, vše
select * from weather;

-- vše, vyjmenované sloupce (atributy)
select id_place, date, temp_lo, temp_hi, precip from weather;

-- vypočítané sloupce
select id_place, date, (temp_hi+temp_lo)/2 as "avg.temp." from weather;

-- s očekávaným počtem desetinných míst
select id_place, date, round((temp_hi+temp_lo)/2, 1) as "avg.temp." from weather;
-- lépe: přetypování (cast)
select id_place, date, ((temp_hi+temp_lo)/2)::d_temp as "avg.temp." from weather;
```

```sql
-- místa
select * from place;

-- jména míst připojená k počasí, místo id místa
select name, date, temp_lo from weather join place on id_place=id; -- chyba
-- id kvalifikované pomocí jména tabulky
select name, date, temp_lo from weather join place on id_place=place.id;
-- aliasy a plná kvalifikace jmen polí
select p.name, w.date, w.temp_lo from weather w join place p on w.id_place=p.id;

-- výběr výsledných řádků podle podmínky
select p.name, w.date, w.temp_lo from weather w join place p on w.id_place=p.id
where p.name='Praha' and 0<w.temp_lo;
```

```sql
-- alias jména sloupce, lze použit v setřídění
select p.name as místo, w.date, w.temp_lo from weather w
join place p on w.id_place=p.id order by místo;
-- setřídění podle více sloupců
select p.name as místo, w.date, w.temp_lo from weather w join place p on w.id_place=p.id order by místo, w.temp_lo;

-- jména míst, všechny záznamy
select p.name as místo from weather w join place p on w.id_place=p.id;
-- také všechny záznamy
select all p.name as místo from weather w join place p on w.id_place=p.id;
-- každé jméno (hodnotu) jen jednou
select distinct p.name as místo from weather w join place p on w.id_place=p.id;

-- každé jméno jen jednou, vybráno podle šablony
select distinct p.name as místo from weather w join place p on w.id_place=p.id
where místo like '%a%'; -- místo: chyba
-- takto lze (co se to děje?)
select distinct p.name as místo from weather w join place p on w.id_place=p.id
where p.name like '%a%' order by místo desc;
```

## Spojování tabulek – `join`

### Vnější spojení (outer join)

Kartézský součin relací:

```sql
select * from place;
select count(*) from place;

select * from weather;
select count(*) from weather;

select * from place, weather;
select count(*) from place, weather;

-- stejné jako: from place, weather
select * from place cross join weather;
```

### Vnitřní spojení (inner join)

Takto bylo realizováno v původní verzi SQL, jako výběr z kartézského součinu:

```sql
select * from place, weather where place.id = id_place;
```

V moderním SQL:

```sql
select * from place inner join weather on place.id = id_place;
-- 'inner' is implied
select * from place join weather on place.id = id_place;
```

### Levé a pravé vnější spojení

Vnitřní spojeni - chybí místa, která nemají záznam o počasí:

```sql
select p.name, w.date, w.temp_hi from place p join weather w on p.id = w.id_place;
```

Levé vnější spojení zachová místa bez záznamů o počasí:

```sql
select p.name, w.date, w.temp_hi from place p left outer join weather w on p.id = w.id_place;
```

Pravé vnější spojení zde nic nepřidá, protože existence místa pro každý záznam o počasí je zaručena vazbou FK/PK:

```sql
select p.name, w.date, w.temp_hi from place p right outer join weather w on p.id = w.id_place;
```

Když ale vyměníme pořadí tabulek, outer join je potřeba:

```sql
select p.name, w.date, w.temp_hi from weather w right outer join place p on p.id = w.id_place;
```

Bez klíčového slova `outer`, totožné:

```sql
select p.name, w.date, w.temp_hi from place p left join weather w on p.id = w.id_place;
```

### Reflexivní spojování tabulek (sama se sebou, reflexive join, self join)

Typické použití: hierarchie a jiné stromové struktury.

```sql
drop table employee;
create table employee (
  id serial primary key,
  name text,
  id_boss integer default null references employee(id)
);

-- bosses
insert into employee(name) values
  ('Hugo'), ('Donald'), ('Sauron');

-- not bosses
insert into employee(id_boss, name) values
  (1, 'Charles'), (1, 'Jenny'),
  (2, 'Mario'), (2, 'Robert'),
  (7, 'Sean');

select
    b.name as boss,
    u.name as underlink
from
    employee b
join -- cross left right
    employee u
on
    b.id = u.id_boss;
```

Další příklad: vyberte dvojice míst, kde v prvním místě byl menší rozsah teplot než v druhém:

```sql
select w1.id_place, w1.date, w1.temp_lo as low, w1.temp_hi as high,
       w2.id_place, w2.date, w2.temp_lo as low, w2.temp_hi as high
  from weather w1 join weather w2
  on w1.temp_lo < w2.temp_lo and w2.temp_hi < w1.temp_hi;
  -- and w1.date=w2.date
```

Úloha: nahraďte `id_place` jmény míst.

### Agregační funkce

> count, min, max, avg, sum, [a další ...](https://www.postgresql.org/docs/current/functions-aggregate.html)

Počet záznamů:

```sql
select count(*) from weather;
select count(id_place) from weather;
select count(distinct id_place) from weather;
```

Kombinace agregačních funkcí a výpočtu:

```sql
select count(*), min(temp_lo), max(temp_hi), avg(temp_hi-temp_lo), sum(precip) from weather;
```

Agregační funkce nelze použít pro selekci:

```sql
select id_place from weather where temp_lo = max(temp_lo); -- X
```

Toto lze provést vnořeným `select`:

```sql
-- select id_place, temp_lo from weather;
-- select max(temp_lo) from weather;
select id_place from weather where temp_lo = (select max(temp_lo) from weather);
```

### Shlukování řádků – `group by`

Při agregaci musí být pole použitá v `select` buď agregovaná nebo uvedená v `group by`.

```sql
select id_place, temp_lo from weather;
select count(*) from weather;
select max(temp_lo) from weather;
select count(*), max(temp_lo) from weather;
select id_place, count(*), max(temp_lo) from weather; -- chyba
select id_place, count(*), max(temp_lo) from weather group by id_place;
```

Filtrování záznamů pro výpočet agregovaných hodnot:

```sql
select id_place, count(*), max(temp_lo) from weather group by id_place;
select id_place, count(*) filter (where temp_lo < 20), max(temp_lo) from weather group by id_place;
```

Selekce agregovaných řádků:

```sql
select id_place, count(*), max(temp_lo) from weather group by id_place;
select id_place, count(*), max(temp_lo) from weather group by id_place having max(temp_hi) < 20;
```

Připojíme jména míst, lze podle nich filtrovat:

```sql
select name, count(*), max(temp_lo) from weather
join place on id_place = place.id where name like '%a%' group by name;

-- two filters: where and having
select name, count(*), max(temp_lo) from weather
join place on id_place = place.id where name like '%a%' group by name having max(temp_hi) < 20;
```

### Views – pohledy

Virtuální, vypočítávaná tabulka:

```sql
create or replace view place_weather as
  select name, date, temp_lo, temp_hi, precip from weather join place on id_place = place.id;

select * from place_weather;
```

Nebo (lépe?) s aliasy:

```sql
create or replace view place_weather as
  select p.name, w.date, w.temp_lo, w.temp_hi, w.precip
  from weather w join place p on w.id_place = p.id;
```

Použití pohledu:

```sql
select name, count(*), max(temp_lo) from place_weather
where name like '%a%' group by name;
```

<!--
## Hierarchie objektů v PostgreSQL:

- _Databáze_
  - `postgres` (default)
    - _Schémata_
      - `public` (default)
        - _Tabulky_
          - `cities`
          - `weather`

Vypište databáze ze systémového katalogu:[^1] [^1]: eat you own dog food

```sql
SELECT * FROM pg_database;
SELECT datname FROM pg_database;
```

Vypište tabulky ze systémového katalogu:

```sql
SELECT * FROM pg_catalog.pg_tables;
SELECT schemaname as schema, tablename as table FROM pg_catalog.pg_tables;
```

```sql
-- UPDATE weather SET temp_lo = -4 WHERE city = 'Louny';
                                                                                              -- UPDATE weather SET temp_hi = 32, temp_lo = temp_hi - 10 WHERE city = 'Louny';                                                                                                            -- DELETE FROM weather WHERE city = 'Hayward';                                                                                                                                              -- DELETE FROM weather;                                                                                                                                                                     -- TRUNCATE weather;
```

TODO location points (latitude, longitude)
CREATE TABLE cities (
  name varchar(80),
  location point
);
INSERT INTO cities VALUES ('San Francisco',  '(37.78, -122.42)');

TODO time zones, preciptation real
TODO weather stations (elevation, coordinates, country, etc.)
TODO countries spanning multiple continents (Russia, Turkey, Egypt, Kazakhstan, Azerbaijan)
TODO indexes (e.g., on place(name), weather(id_place, date), etc.)
TODO views (e.g., avg monthly temp per place, etc.)
TODO stored procedures (e.g., add_weather_data(place_name, date, temp_hi, temp_lo, precip), etc.)
TODO import from CSV
-->
