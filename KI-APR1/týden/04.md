# 04 ‚Äì Podm√≠nky, cykly, indexace, ≈ôetƒõzce ...

## Logick√© v√Ωrazy

Jsou operace s hodnotami typu `bool`: `False` a `True`.

Logicke operace jsou: logick√Ω souƒçin (konjunkce) `and`, logick√Ω souƒçet (disjunkce) `or` a logick√° negace `not`. Precedence (p≈ôednost) tƒõchto oper√°tor≈Ø je `not`,`and`,`or`.

Tyto operace lze popsat _pravdivostn√≠mi tabulkami_ ( F=`False`, T=`True`):

| a   | b   | a and b |
| :-- | :-- | ------: |
| F   | F   |       F |
| F   | T   |       F |
| T   | F   |       F |
| T   | T   |       T |

| a   | b   | a or b |
| :-- | :-- | -----: |
| F   | F   |      F |
| F   | T   |      T |
| T   | F   |      T |
| T   | T   |      T |

| a   | not a |
| :-- | ----: |
| F   |     T |
| T   |     F |

### √öloha:

Napi≈°te program, kter√Ω vypoƒç√≠t√° a vyp√≠≈°e pravdivostn√≠ tabulky v√Ω≈°e uveden√Ωch operac√≠.

#### üß© Mo≈æn√° ≈ôe≈°en√≠:

Jednoduch√° verze pro dvƒõ vstupn√≠ hodnoty:

```python
print('and')
for a in [False, True]:
  for b in [False, True]:
    print(a, b, a and b)

print()

print('or')
for a in [False, True]:
  for b in [False, True]:
    print(a, b, a or b)

print()

print('not')
for a in [False, True]:
  print(a, not a)
```

Pro t≈ôi vstupn√≠ hodnoty, l√©pe form√°tovan√Ω v√Ωstup:

```python
# p≈ôevod hodnoty na 'T'/'F' pro lep≈°√≠ ƒçitelnost
def ft(val):
  return 'T' if val else 'F'

print('** and **')
for a in [False, True]:
  for b in [False, True]:
    for c in [False, True]:
      print(ft(a), ft(b), ft(c), '|', ft(a and b and c))
```

DRY:

```python
def ft(val):
  return 'T' if val else 'F'

vals = [False, True] # <<<

print('** and **')
for a in vals:
  for b in vals:
    for c in vals:
      print(ft(a), ft(b), ft(c), '|', ft(a and b and c))
```

A je≈°tƒõ l√©pe pomoc√≠ znak≈Ø na [kreslen√≠ r√°meƒçk≈Ø](https://en.wikipedia.org/wiki/Box-drawing_characters):

```python
def ft(val):
  return 'T' if val else 'F'

vals = [False, True]

print('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê')
print('‚îÇ a b c : * ‚îÇ')
print('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§')

for a in vals:
  for b in vals:
    for c in vals:
      print('‚îÇ', ft(a), ft(b), ft(c), ':', ft(a and b and c), '‚îÇ')

print('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò')
```

Nebo pomoc√≠ `int`:

```python
print('a b c | y')
print('---------')

vals = [0, 1]

for a in vals:
  for b in vals:
    for c in vals:
      print(a, b, c, '|', a and b and c)
```

P≈ôi pou≈æit√≠ `int`, v√Ωsledek `not` je nutno p≈ôev√©st zpƒõt na `int`:

```python
print('a | not a')
print('---------')

vals = [0, 1]

for a in vals:
  print(a, '|', int(not a), not a)
```

## Dal≈°√≠ logick√© operace

Dal≈°√≠ logick√© operace jsou nap≈ô. [implikace](https://cs.wikipedia.org/wiki/Implikace) (jestli≈æe _a_, pak _b_) a [exkluzivn√≠ disjunkce](https://cs.wikipedia.org/wiki/Exkluzivn%C3%AD_disjunkce) (exclusive or, _xor_), definovan√© tƒõmito tabulkami:

| a   | b   | implikace |
| :-- | :-- | --------: |
| F   | F   |         T |
| F   | T   |         T |
| T   | F   |         F |
| T   | T   |         T |

| a   | b   | xor |
| :-- | :-- | --: |
| F   | F   |   F |
| F   | T   |   T |
| T   | F   |   T |
| T   | T   |   F |

### √öloha:

Vyj√°d≈ôete operace **implikace** a **xor** pomoc√≠ oper√°tor≈Ø **and**, **or**, **not**.

#### üß© ≈òe≈°en√≠:

- implikace: `not a or b`
- xor: `a and not b or not a and b`
- xor: `a != b`

Ovƒõ≈ôen√≠ pravdivostn√≠ tabulkou:

```python
vals = [0, 1]

for a in vals:
  for b in vals:
    print(a, b, '|', int(not a or b), int(a and not b or not a and b), int(a!=b))
```

## NAND

Pozn√°mka: Ve skuteƒçnosti by n√°m staƒçil jen jedin√Ω logick√Ω oper√°tor: _nand_ (not and). V≈°echny ostatn√≠ operace je mo≈æn√© zkonstruovat pomoc√≠ tohoto oper√°toru.

| a   | b   | nand |
| :-- | :-- | ---: |
| F   | F   |    T |
| F   | T   |    T |
| T   | F   |    T |
| T   | T   |    F |

#### üß© ≈òe≈°en√≠:

- not: `a nand a`
- and: `not (a nand b)`
- or: `not a nand not b`
- implikace: `a nand (a nand b)`
- xor: `(not a nand b) nand (not b nand a)`

Ovƒõ≈ôen√≠ pravdivostn√≠ tabulkou:

```python
vals = [0, 1]

for a in vals:
  for b in vals:
    print(a, b, '|', int(not a or b), int(a and not b or not a and b), int(a!=b))
```

## De Morganovy z√°kony

[De Morganovy z√°kony](https://cs.wikipedia.org/wiki/De_Morganovy_z%C3%A1kony) jsou pravidla, kter√° tvrd√≠:

1. Negace v√Ωsledku logick√©ho souƒçinu promƒõnn√Ωch = logick√Ω souƒçet znegovan√Ωch promƒõnn√Ωch
1. Negace logick√©ho souƒçtu logick√Ωch hodnot = logick√Ω souƒçin negovan√Ωch hodnot

To jest:

```
not (a and b) == not a or  not b
not (a or  b) == not a and not b
```

### √öloha:

Provƒõ≈ôte pomoc√≠ k√≥du, ≈æe De Morganova pravidla opravdu plat√≠.

#### üß© Mo≈æn√° ≈ôe≈°en√≠:

```python
for a in [0, 1]:
  for b in [0, 1]:
    for c in [0, 1]:
      v1 = int(not (a and b and c))
      v2 = int(not a or not b or not c)
      print(a, b, c, '|', v1, v2, '|', v1==v2)
```

```python
holds = True

for a in [0, 1]:
  for b in [0, 1]:
    for c in [0, 1]:
      v1 = int(not (a and b and c))
      v2 = int(not a or not b or not c)
      if v1 != v2:
        holds = False

print('De Morganovo pravidlo', 'plat√≠' if holds else 'neplat√≠')
```

## Palindromy

Na p≈ôedn√°≈°ce byl (nebo bude) sestaven program, kter√Ω ovƒõ≈ôoval, zda zadan√Ω ≈ôetƒõzec (vƒõta) je palindrom. P≈ôi testu ƒçesk√Ωch palindrom≈Ø se ignoruje:

- velikost p√≠smen
- ƒç√°rky a krou≈æek nad: √°, √©, √≠, √≥, √∫, ≈Ø, √Ω
- ƒç√≠slice
- mezery a jin√© speci√°ln√≠ znaky

### √öloha:

Napi≈°te program na rozpozn√°n√≠ palindromu.

#### üß© Mo≈æn√© ≈ôe≈°en√≠:

```python
def onlyAlpha(s):
  """ Ponech√° jen p√≠smena. """
  s2 = ''
  for c in s:
    if c.isalpha():
      s2 += c

  return s2

def shortenVowels(s):
  """ P≈ôedpokl√°d√° mal√° p√≠smena, zkr√°t√≠ samohl√°sky. """
  t1 = '√°√©√≠√≥√∫≈Ø√Ω' # tyto nahrad√≠
  t2 = 'aeiouuy' # tƒõmito
  for i in range(len(t1)):
    s = s.replace(t1[i],t2[i])

  return s

def isReversible(s):
  """ Je s stejn√Ω i po obr√°cen√≠? """
  for i in range(len(s)//2): # staƒç√≠ j√≠t do poloviny
    if s[i] != s[-i-1]:      # pokud p√≠smeno poƒç√≠tan√© od zaƒç√°tku je jin√© ne≈æ od konce
      return False           # p≈ôedƒçasn√Ω n√°vrat
  return True                # p≈ôedƒçasn√Ω n√°vrat nenastal, s je reverzibiln√≠

# vstup, konverze na mal√° p√≠smena
s = input('Vƒõta: ').lower()

isPalindrom = isReversible(shortenVowels(onlyAlpha(s)))

print(isPalindrom)

# K zamy≈°len√≠:

# isReversible() zji≈°≈•uje, zda je ≈ôetƒõzec po obr√°cen√≠ stejn√Ω,
# pomoc√≠ tzv. "in-place" algoritmu, tj. bez nutnosti vytv√°≈ôet kopie
# dat, jak tomu je nap≈ô. p≈ôi pou≈æit√≠ v√Ωrazu s==s[::-1].

# Bylo by mo≈æn√© napsat cel√Ω program na rozezn√°n√≠ palindromu
# ani≈æ by se vytv√°≈ôely jak√©koli kopie vstupn√≠ho ≈ôetƒõzce,
# jako to zde dƒõlaj√≠ funkce onlyAlpha() a shortenVowels() ?
```

## Indexace

Indexy (pozice element≈Ø v kolekc√≠ch, nap≈ô. p√≠smena v ≈ôetƒõzci) se ve vƒõt≈°inƒõ programovac√≠ch jazyk≈Ø poƒç√≠taj√≠ od nuly. Proƒç? Proto≈æe tzv. [modul√°rn√≠ aritmetika](https://cs.wikipedia.org/wiki/Modul%C3%A1rn%C3%AD_aritmetika) leccos zjednodu≈°uje!

```python
s = 'abcd'
s[0] # 'a'
```

S t√≠m souvis√≠ i skuteƒçnost, ≈æe `range(i,j)` p≈ôedstavuje interval hodnot zleva uzav≈ôen√Ω ("vƒçetnƒõ i") a zprava otev≈ôen√Ω ("vyjma j"). Takov√© intervaly lze, mimo jin√©, mnohem jednodu≈°≈°eji skl√°dat:

```python
# range() vrac√≠ objekt, nutno p≈ôev√©st na seznam
print(list(range(8)))
print(list(range(8,16)))
print(list(range(16,23)))
print(list(range(0,8)) + list(range(8,16)) + list(range(16,23)))
```
