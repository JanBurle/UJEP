# Vnímání zvuku

## Python toolbox

Na základě Python kódu z předchozího týdne si vytvoříme toolbox pro další experimenty.

**typy a pomocné funkce**

```python
import numpy as np
pi  = np.pi # π
pi2 = 2*pi  # 2π

# sampling rate
sr = 48000

# types
Dur = float # [sec] duration
Smp = int   # [1]   duration as number of samples

Frq = float # [cps]
Phs = float # [rad]
Amp = float # [1]

Flt = np.float32  # 32b numpy float
Arr = np.ndarray  # numpy array
Tim = Arr         # time points

# duration to number of samples
def toSmp(dur: Dur) -> Smp:
  return int(sr * dur)

# number of samples to duration
def toDur(n: Smp) -> Dur:
  return n / sr
```

**třídy**

```python
from __future__ import annotations # allows forward typing

# audio buffer
class Buf:
  # dur: optionally preallocate space
  def __init__(self, dur: Dur = 0):
    self.buf = np.zeros(toSmp(dur), Flt)

  # time sequence
  def tim(self, numSmp: Smp, start: Dur = 0) -> Tim:
    return np.linspace(start, start+toDur(numSmp), numSmp, dtype=Flt, endpoint=False)

  # area under the curve
  def area(self) -> Flt:
    return np.sum(self.buf) / sr

# generic wave (sine)
class Wave(Buf):
  def __init__(self, dur: Dur, amp: Amp, frq: Frq, phs: Phs = 0, fade = True):
    super().__init__()
    self._make(dur, amp, frq, phs, fade)

  # wrap in a Wave
  @staticmethod
  def fromBuf(buf: Arr) -> Wave:
    wave = Wave(0, 0, 0, 0)
    wave.buf = buf
    return wave

  # numpy function that geneates the wave
  def _npFn(self):
    return np.sin

  def _make(self, dur: Dur, amp: Amp, frq: Frq, phs: Phs, fade: bool):
    self.buf = amp * self._npFn()(pi2 * frq * self.tim(toSmp(dur)) + phs)
    if(fade): self._fade()

  def _fade(self):
    FADE_DUR = .06
    numSmp = min(toSmp(FADE_DUR), len(self.buf))
    attack = np.linspace(0, 1, numSmp)
    decay  = np.linspace(1, 0, numSmp)

    self.buf[:numSmp]  *= attack
    self.buf[-numSmp:] *= decay

  # product
  def __mul__(self, other: Wave) -> Wave:
    return Wave.fromBuf(self.buf * other.buf)

class SinWave(Wave):
  pass

class CosWave(Wave):
  def _npFn(self):
    return np.cos

# audio wrapper
class Audio(Buf):
  def __init__(self, dur: Dur = 0):
    super().__init__(dur)

  def add(self, wave: Wave, at: Dur = 0) -> Audio:
    beg = int(at*sr)
    end = beg + len(wave.buf)
    lgt = len(self.buf)

    if lgt < end: # extend, if needed
      buf = np.zeros(end, Flt)
      buf[:lgt] = self.buf
      self.buf = buf

    # add wave
    self.buf[beg:end] += wave.buf

    # chaining
    return self

  def plot(self, dur: Dur|None = None, beg: Dur = 0):
    import matplotlib.pyplot as plt

    plt.figure(figsize=(8, 3))
    plt.grid(True)
    plt.ylim(-1, +1)

    tim = self.tim(len(self.buf))
    buf = self.buf

    b = toSmp(beg)

    if dur is None:
      plt.plot(tim[b:], buf[b:])
    elif 0 < dur:
      n = toSmp(dur)
      plt.plot(tim[b:b+n], buf[b:b+n])
    else:
      n = toSmp(dur)
      plt.plot(tim[n:], buf[n:])

    plt.show()

  def display(self):
    from IPython.display import Audio
    # prevent automatic scaling
    display(Audio(np.clip(self.buf, -1.0, 1.0), rate=sr))

  def show(self, dur: Dur|None = None, beg: Dur = 0):
    self.plot(dur, beg)
    self.display()
```

**příklad použití: přídávání vln**

```python
audio = Audio()
wave  = SinWave(1, .6, 240)

audio.add(wave, 0)
audio.add(wave, 1.5)

audio.show()
```

## Pokusy: vnímání kmitočtu a rozkmitu (frequency, amplitude)

lineárně rostoucí kmitočet

```python
audio = Audio()

dur = .8
amp = .6
frq = 0
at  = 0 # time

while frq <= 8000:
  audio.add(SinWave(dur, amp, frq), at)
  frq += 250; at += dur + .1

audio.show()
```

_logaritmicky_ rostoucí kmitočet

```python
audio = Audio()

dur = .8
amp = .6
frq = 20
at  = 0

while frq <= 8000:
  audio.add(SinWave(dur, amp, frq), at)
  frq *= 5/4; at += dur + .1

audio.show()
```

lineárně rostoucí amplituda

```python
audio = Audio()

dur = .8
amp = .05
frq = 1000
at  = 0

while amp < 1:
  audio.add(SinWave(dur, amp, frq), at)
  amp += 0.05; at += dur + .1

audio.show()
```

logaritmicky rostoucí amplituda

```python
audio = Audio()

dur = .8
amp = .05
frq = 1000
at  = 0

while amp < 1:
  audio.add(SinWave(dur, amp, frq), at)
  amp *= 1.4; at += dur + .1

audio.show()
```

### Závěr

Vnímání zvuku má, _zdá se_, logaritmický charakter. (❓)

## První melodie

```python
# MIDI tone numbers
midi = [83,81,83,78,74,78,71,0,83,81,83,78,74,78,71,0,83,85,86,85,86,83,85,83,85,81,83,81,83,79,83,0]

# 12TET (twelve-tone equal temperament) conversion to frequency (exponential!)
def toFrq(midi): return 440 * 2**((midi-69)/12)

audio = Audio(7)

dur = .08 # tone length
spc = .2  # spacing between tones
amp = .6

for i,m in enumerate(midi):
  if m: audio.add(SinWave(dur, amp, toFrq(m)), .4 + i*spc)

audio.show()
```

# Historie

- [John R. Pierce, Variations in Timbre and Attack, 1961](https://youtu.be/vKyYL6MXcv0)
- [John Chowning, Sabelithe 1971](https://youtu.be/53FQCe1ewDs)
