# 08 – Uživatelé, procedury, triggery

<details>
<summary>Pracovní tabulky</summary>

```sql
drop table if exists weather;
drop table if exists city;

create table city (
  id char(2) primary key,
  name varchar(80) not null
);

create table weather (
  city_id char(2) references city(id),
  temp_lo int not null,
  temp_hi int not null,
  date date not null default current_date,
  primary key (city_id, date),
  constraint check_temp check(temp_lo <= temp_hi)
);

create index idx_date on weather(date);

do $$
declare
  id char(2); id1 integer; id2 integer; name varchar(80);
  temp_lo integer; temp_hi integer; weather_date date; days integer;
begin
  for id1 in ascii('a')..ascii('z') loop
    for id2 in ascii('a')..ascii('z') loop
      id := chr(id1) || chr(id2);
      name := 'City ' || upper(id);
      insert into city (id, name) values (id, name);

      for days in 0 .. 30 loop
        temp_lo := (random() * 30)::int;
        temp_hi := temp_lo + (random() * 10)::int;
        weather_date := current_date - days;
        insert into weather (city_id, temp_lo, temp_hi, date)
          values (id, temp_lo, temp_hi, weather_date);
      end loop;

    end loop;
  end loop;
end $$;
```

</details>

## Skupiny, uživatelé, role

Dřívější `create group`, `create user` jsou dnes v Postgresu totéž jako `create role`.

Jiné DBS: `user` se přihlašuje. V Postgresu v zásadě není rozdíl.

Superuser je definovaný v docker skriptu.

Vytvořený obyčejný uživatel:

```sql
select current_user;
create user joe password 'joepwd';
```

Otevřeme databázové spojení pro Pepu a pak:

```sql
-- joe
select current_user;
select * from city;  -- doh
delete from weather; -- that's safety
update weather set temp_hi=30 where date='2024-11-09';
```

Jako superuser dáme nebo odebereme Pepovi oprávnění:

```sql
-- dbuser
grant select on city to joe;
grant select,update on weather to joe;
revoke select on city from joe;
revoke all on city, weather from joe;
```

Nebo vytvoříme roli (skupinu) s oprávněními, a Pepovi oprávnění skupiny:

```sql
create role reader;
grant select on city to reader;

grant reader to joe;
revoke reader from joe;
```

## Triggery

Jsou funkce psané v PL/pgSQL, PL/Tcl, PL/Perl, PL/Python, připojené k tabulkám nebo pohledům, automaticky prováděné za určité situace.

Na tabulkách:

- před nebo po `insert`, `update`, `delete` (before, after)
- jednou pro každou řádku nebo jednou pro celý příkaz (per-row, per-statement)
- `update` trigger při změně určitého sloupce
- při `truncate`

Interakce může být složitá, je nutno vzít v úvahu pořadí operací, a viditelnost změn (rozdíly podle `volatile`, `stable`, `immutable` funkce).

Na pohledech:

- místo (instead of) `insert`, `update`, `delete`

Při změnách v databázi:

- login
- tabulky: `alter`, `create`, `drop`, ...

## Psaní triggerů

Funkce bez parametrů, vstup je implicitní: `new.*`, `old.*` (pomocí struktury TriggerData), vrací typ _trigger_.

### Příklady

Login:

```sql
create table audit_log (
  id serial primary key,
  ts timestamp default current_timestamp,
  tx text
);

create or replace function init_session() returns event_trigger
security definer
language plpgsql as $$
declare
  hour integer = extract('hour' from current_time);
begin
  -- forbid early logging in
  if hour between 0 and 5 then
    raise exception 'login forbidden: %', hour;
  end if;

  insert into audit_log (tx) values ('login: ' || session_user);
end; $$;

create or replace event trigger init_session on login
  execute function init_session();

```

```sql
select * from audit_log;
```

Audit log (journal/žurnál/deník):

```sql
create or replace function weather_insert_log()
  returns trigger language plpgsql as $$
begin
  insert into audit_log (tx) values ('new weather: ' || new.*);
  return new;
end; $$;

create or replace trigger weather_insert_log
  before insert on weather
for each row execute function weather_insert_log();

delete from weather where city_id='at';
select * from weather where city_id='at';
select * from audit_log;

insert into weather values('at', 2, 3);
```

Oprava chybných hodnot při vkládání:

```sql
insert into weather (city_id, temp_lo, temp_hi, date)
  values ('aa', 22, 11, '2025-11-22');
```

```sql
create or replace function trg_fix_temps() returns trigger as $$
begin
  if new.temp_lo > new.temp_hi then -- swap the values
    declare tmp int;
    begin
      tmp := new.temp_lo;
      new.temp_lo := new.temp_hi;
      new.temp_hi := tmp;
    end;
  end if;
  return new;
end;
$$ language plpgsql;

create or replace trigger fix_temps_before_insert before insert on weather
for each row execute function trg_fix_temps();
```

Neumožní vložení budoucích dat:

```sql
create or replace function trg_no_future() returns trigger as $$
begin
  if current_date < new.date then
    raise exception 'No future date (%)!', new.date;
    -- return null; <<< to silently skip the row instead of error >>>
  end if;
  return new;
end;
$$ language plpgsql;

create or replace trigger no_future_before_insert before insert on weather
for each row execute function trg_no_future();
```

```sql
insert into weather (city_id, temp_lo, temp_hi, date)
  values ('aa', 22, 11, '2099-11-24');
```

Žurnál změn v tabulce:

```sql
create or replace function trg_weather_journal() returns trigger as $$
begin
  if (tg_op = 'INSERT') then
    insert into weather_journal(action, city_id, temp_lo, temp_hi, date)
    values('INSERT', new.city_id, new.temp_lo, new.temp_hi, new.date);

    return new;

  elsif (tg_op = 'UPDATE') then
    insert into weather_journal(action, city_id, temp_lo, temp_hi, date)
    values('UPDATE', new.city_id, new.temp_lo, new.temp_hi, new.date);

    return new;

  elsif (tg_op = 'DELETE') then
    insert into weather_journal(action, city_id, temp_lo, temp_hi, date)
    values('DELETE', old.city_id, old.temp_lo, old.temp_hi, old.date);

    return old;
  end if;
end;
$$ language plpgsql;
```
