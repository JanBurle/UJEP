# 08 â€“ Operace nad seznamy (Å™azenÃ­)

VytvoÅ™te si seznamy:

```python
# homogennÃ­ seznamy, celÃ¡ ÄÃ­sla
numbers  = [1, 2, 3, 4, 5]
unsorted = [1, 3, 2, 4, 5]

backward = list(reversed(numbers))
longOne1 = list(range(1000))
longOne2 = list(range(10_000))

# homogennÃ­ seznam, Å™etÄ›zce
words    = ["apple", "banana", "cherry"]

# heterogennÃ­ seznam
mixed    = [1, "hello", 3.14]
```

## SeÅ™azenÃ© seznamy

```python
help(sorted)
help(reversed)
sorted(words)   # vrÃ¡tÃ­ seÅ™azenou kopii seznamu
reversed(words) # vrÃ¡tÃ­ iterÃ¡tor, kterÃ½ iteruje seznam pozpÃ¡tku
```

ZjistÄ›te, zda je seznam seÅ™azenÃ½:

```python
def isSorted1(lst:list) -> bool:
  return lst == sorted(lst)

# isSorted1([]) # ?
# isSorted1(numbers)

# isSorted1(backward)
# isSorted1(reversed(backward))       # wrong, see type annotation!
# isSorted1(list(reversed(backward))) # correct
```

ZjistÄ›te, zda je seznam seÅ™azenÃ½, aniÅ¾ by se vytvÃ¡Å™el a Å™adil novÃ½ seznam:

```python
def isSorted2a(lst:list) -> bool:
  result = True
  for i in range(len(lst) - 1):
    result = result and lst[i] <= lst[i+1]
  return result

isSorted2a(numbers)
```

Nebo:

```python
def isSorted2b(lst:list) -> bool:
  result = True
  for i in range(1, len(lst)):
    result = result and lst[i-1] <= lst[i]
  return result

isSorted2b(numbers)
```

PouÅ¾ijeme _pÅ™edÄasnÃ½ nÃ¡vrat_ (early return) z funkce:

```python
def isSorted3(lst:list) -> bool:
  for i in range(len(lst) - 1):
    if not lst[i] <= lst[i+1]:
      return False
  return True

isSorted3(unsorted)
```

Porovnejme rychlost (Äasovou sloÅ¾itost?):

```python
%time isSorted1(longOne2)
%time isSorted2a(longOne2)
%time isSorted3(longOne2)
```

## ğŸ“± Ãšloha

Seznam `backward` je sice seÅ™azenÃ½, ale opaÄnÄ› (sestupnÄ›):

```python
isSorted1(backward) # False
```

NapiÅ¡te funkci, kterÃ¡ zjistÃ­, jestli je seznam seÅ™azenÃ½ libovolnÃ½m smÄ›rem.

```python
def isSorted4(lst: list) -> bool:
  ...

isSorted4(numbers)
isSorted4(backward)
isSorted4(words)
isSorted4(unsorted)
```

## VestavÄ›nÃ© funkce min, max, sum

VestavÄ›nÃ© funkce `min()` a `max()` naleznou v seznamu nejmenÅ¡Ã­ a nejvÄ›tÅ¡Ã­ hodnotu:

```python
min(numbers)
max(numbers)
min(words)
max(words)
```

Nad seznamem ÄÃ­sel lze takÃ© pouÅ¾Ã­t vestavÄ›nou funkci `sum()`, kterÃ¡ ÄÃ­sla seÄte:

```python
sum(numbers)
```

Ale ne:

```python
sum(words)
```

## ğŸ“± Ãšloha

Bez pouÅ¾itÃ­ vestavÄ›nÃ½ch funkcÃ­ `min(), max(), sum(), ...` napiÅ¡te funkce, kterÃ© (pomocÃ­ cyklu)

- najdou v seznamu nejmenÅ¡Ã­ prvek
- najdou v seznamu nejvÄ›tÅ¡Ã­ prvek
- seÄtou prvky (ÄÃ­sla)
- vynÃ¡sobÃ­ prvky (ÄÃ­sla)

NejdÅ™Ã­ve se zamyslete nad tÃ­m, jakÃ½ vÃ½sledek by funkce mÄ›ly vrÃ¡tit pro prÃ¡zdnÃ½ seznam.

## ğŸ“± Ãšloha

RozÅ¡iÅ™te vaÅ¡e funkce kterÃ© najdou v seznamu nejmenÅ¡Ã­ a nejvÄ›tÅ¡Ã­ prvek tak, aby vrÃ¡tily dvojici _(index prvku, hodnota prvku)_.

NÃ¡povÄ›da:

```python
for elem in mixed:
  print(elem)

for i in range(len(mixed)):
  print(i)

# Takto?
for i,elem in enumerate(mixed):
  print(i,elem)
```

## HeterogennÃ­ seznamy

Prvky heterogennÃ­ho seznamu nelze jednoduÅ¡e porovnÃ¡vat:

```python
isSorted2a(mixed) # vÃ½jimka
```

NapiÅ¡me si funkci na porovnÃ¡nÃ­ dvou hodnot:

`compare` by se takÃ© mohlo jmenovat

- `lt`: less than
- `le`: less than or equal
- `gt`: greater than
- `ge`: greater than or equal
- `eq`: equal
- `ne`: not equal

```python
def compare(a,b) -> bool:
  """Is *a* less than or equal to *b*?"""
  return a <= b

compare(2,3)      # ok
compare('x','y')  # ok
compare(2,'y')    # NOT ok
```

VestavÄ›nou funkcÃ­ `isinstance()` lze za bÄ›hu programu zjistit, zda hodnota mÃ¡ urÄitÃ½ typ:

```python
i = 3
f = 3.14
s = 'abc'

# integer?
isinstance(i, int)
isinstance(f, int)
isinstance(s, int)

# float?
isinstance(i, float)
isinstance(f, float)
isinstance(s, float)

# string?
isinstance(i, str)
isinstance(f, str)
isinstance(s, str)

# number?
isinstance(i, (int, float))
isinstance(f, (int, float))
isinstance(s, (int, float))
```

A pak lze napsat funkci, kterÃ¡ porovnÃ¡ ÄÃ­sla **i** Å™etÄ›zce:

```python
def compare(a: int|float|str, b: int|float|str) -> bool:
  """Compare numbers or strings. Numbers come first."""
  if isinstance(a, str):
    return a<=b if isinstance(b, str) else False
  else:
    return True if isinstance(b, str) else a<=b
```

Funkci lze zkrÃ¡tit:

```python
def compare(a: int|float|str, b: int|float|str) -> bool:
  if isinstance(a, str) == isinstance(b, str):
    return a <= b # a and b are either both strings, or both numbers

  # comparing string/number, True if b is a string (a is a number)
  return isinstance(b, str)
```

## ğŸ“± Ãšloha

Upravte vaÅ¡i funkci (napÅ™.) `isSorted4()` tak, aby dokÃ¡zala urÄit zda _heterogennÃ­_ seznam je seÅ™azen:

```python
isSorted4(mixed)
```

## Adaptace vestavÄ›nÃ½ch funkcÃ­

VestavÄ›nÃ© funkce _min(), max(), sorted(), list.sort()_ lze adaptovat pomocÃ­ pojmenovanÃ©ho parametru _key_:

```python
help(min)
help(max)
help(sorted)
help(list.sort)
```

## ğŸ“± Ãšloha z minulÃ©ho cviÄenÃ­: HrÃ¡Äi

MÄ›jme seznam hrÃ¡ÄÅ¯ a jejich skÃ³re v turnaji. VypiÅ¡te jmÃ©no nejlepÅ¡Ã­ho a nejhorÅ¡Ã­ho hrÃ¡Äe (podle skÃ³re).

```python
hrÃ¡Äi = [("Pavel", 3), ("Honza", 5), ("Jana", 7), ("Milan", 4), ("Michaela", 9)]
```

Funkce _max_ vypÃ­Å¡e "nejvÄ›tÅ¡Ã­" prvek seznamu, podle abecedy:

```python
max(hrÃ¡Äi)
```

NapÃ­Å¡eme-li funkci, kterÃ¡ vracÃ­ skÃ³re hrÃ¡Äe, a pÅ™edÃ¡me-li ji jako parametr _key_, dostaneme hrÃ¡Äe s nejvÄ›tÅ¡Ã­m skÃ³re:

```python
def score(hrÃ¡Ä):
  return hrÃ¡Ä[1]

max(hrÃ¡Äi, key=score)
```

Nebo hrÃ¡Äe s nejmenÅ¡Ã­m skÃ³re:

```python
min(hrÃ¡Äi, key=score)
```

Nebo seznam hrÃ¡ÄÅ¯ setÅ™Ã­dÄ›nÃ½ podle skÃ³re:

```python
sorted(hrÃ¡Äi, key=score)
```

## AnonymnÃ­ (lambda) funkce

[AnonymnÃ­ funkce](https://en.wikipedia.org/wiki/Anonymous_function) je funkÄnÃ­ objekt zapsanÃ½ bez pomoci klÃ­ÄovÃ©ho slova `def` a beze jmÃ©na. AnonymnÃ­ funkci lze pouÅ¾Ã­t napÅ™. jako pÅ™Ã­mÃ½ argument (literÃ¡l) pro adaptaci vestavÄ›nÃ½ch funkcÃ­:

```python
min(hrÃ¡Äi, key=lambda x: x[1])
```

```python
max(hrÃ¡Äi, key=lambda x: x[1])
```

## ğŸ“± Ãšloha

MÄ›jme seznam 3D bodÅ¯:

```python
from random import uniform as uniRnd

def randomPoint(scale = 100):
  x = uniRnd(-scale, +scale)
  y = uniRnd(-scale, +scale)
  z = uniRnd(-scale, +scale)
  return (x,y,z)

points = []
for _ in range(60):
  points.append(randomPoint())

points[:4]
```

PomocÃ­ vestavÄ›nÃ½ch funkcÃ­ _min(), max(), sorted()_ a lambda funkce pouÅ¾itÃ© jako parametr _key_:

- najdÄ›te bod s nejmenÅ¡Ã­/nejvÄ›tÅ¡Ã­ souÅ™adnicÃ­ x, y, z
- vypiÅ¡te seznam bodÅ¯ seÅ™azenÃ½ podle souÅ™adice x, y, z

## Å˜azenÃ­ seznamÅ¯

### ğŸ“± Ãšloha

Pro procviÄenÃ­ napiÅ¡te funkci, kterÃ¡ bez pouÅ¾itÃ­ vestavÄ›nÃ½ch funkcÃ­ `reversed(...)` a `...reverse()` obrÃ¡tÃ­ seznam Â¨in-placeÂ¨.

```python
def reverseInPlace(lst: list):
  for i in ...
    ...

a = [2,4,3,5]
reverseInPlace(a)
a
# [5, 3, 4, 2]
```

### ğŸ“± Ãšloha

Pro procviÄenÃ­ naprogramujte funkci, kterÃ¡ seÅ™adÃ­ seznam "in-place" pomocÃ­ algoritmu [bublinkovÃ©ho Å™azenÃ­](https://cs.wikipedia.org/wiki/Bublinkov%C3%A9_%C5%99azen%C3%A).

```python
def bubbleSort(lst: list):
  ...

a = [5,4,2,3,1]
bubbleSort(a)
a
# [1, 2, 3, 4, 5]
```

### ğŸ“± Ãšloha

Naprogramujte jinÃ½ [Å™adicÃ­ algoritmus](https://cs.wikipedia.org/wiki/Kategorie:%C5%98adic%C3%AD_algoritmy).

NapÅ™.:

- v celÃ©m seznamu (od poÄÃ¡teÄnÃ­ pozice) najdi nejmenÅ¡Ã­ prvek
- vymÄ›Åˆ jej s prvnÃ­m prvkem
- od druhÃ© pozice v seznamu najdi nejmenÅ¡Ã­ prvek
- vymÄ›Åˆ jej s druhÃ½m prvkem
- od tÅ™etÃ­ pozice v seznamu najdi nejmenÅ¡Ã­ prvek
- ... atd aÅ¾ do konce

# ğŸ§© MoÅ¾nÃ¡ Å™eÅ¡enÃ­:

## SeÅ™azenÃ© seznamy

NapiÅ¡te funkci, kterÃ¡ zjistÃ­, jestli je seznam seÅ™azenÃ½ libovolnÃ½m smÄ›rem.

```python
# BAD
def isSorted4(lst: list) -> bool:
  return isSorted1(lst) or isSorted1(list(reversed(lst)))
```

```python
# using list comprehension
# UGLY
def isSorted4(lst:list) -> bool:
  upward   = all(lst[i]<=lst[i+1] for i in range(len(lst)-1))
  downward = all(lst[i]>=lst[i+1] for i in range(len(lst)-1))
  return upward or downward
```

```python
# GOOD
def isSorted4(lst: list) -> bool:
  if len(lst) < 3: return True # corner case

  dir = 0 # direction 0: not known, +1 up, -1 down
  for i in range(0, len(lst)-1):
    a, b = lst[i], lst[i+1]
    if 0 < dir: # up
      if a > b: return False
    elif dir < 0: # down
      if a < b: return False
    else: # not known yet
      if a < b: dir = +1
      elif a > b: dir = -1

  return True

isSorted4([])
isSorted4([0])
isSorted4(numbers)
isSorted4(backward)
isSorted4(words)
isSorted4(unsorted)
```

## min, max, sum

Bez pouÅ¾itÃ­ vestavÄ›nÃ½ch funkcÃ­ `min(), max(), sum(), ...` napiÅ¡te funkce, kterÃ© (pomocÃ­ cyklu)

- najdou v seznamu nejmenÅ¡Ã­ prvek
- najdou v seznamu nejvÄ›tÅ¡Ã­ prvek
- seÄtou prvky (ÄÃ­sla)
- vynÃ¡sobÃ­ prvky (ÄÃ­sla)

NejdÅ™Ã­ve se zamyslete nad tÃ­m, jakÃ½ vÃ½sledek by funkce mÄ›ly vrÃ¡tit pro prÃ¡zdnÃ½ seznam.

```python
def myMin(lst:list):
  if not list: return None
  min = lst[0]
  for elem in lst[1:]:
    if elem<min: min = elem

  return min

myMin([1, 3, 2, -1, 4, 5])
```

```python
# def myMax ...
```

```python
def mySum(lst: list[int|float]) -> int|float:
  sum = 0

  for elem in lst:
    sum += elem

  return sum

mySum([1, 3, 2, -1, 4, 5.6])
```

```python
# def myProduct ...
```

RozÅ¡iÅ™te vaÅ¡e funkce, kterÃ© najdou v seznamu nejmenÅ¡Ã­ a nejvÄ›tÅ¡Ã­ prvek, tak aby vrÃ¡tily dvojici (index prvku, hodnota prvku).

```python
def myMin(lst:list):
  res = None
  for i,elem in enumerate(lst):
    if not res or elem<res[1]:
      res = (i,elem)

  return res

myMin([-11, 3, 2, -1, 4, 5])
# myMin([])
```

## In-place reverze a Å™azenÃ­ seznamu

NapiÅ¡te funkci, kterÃ¡ bez pouÅ¾itÃ­ vestavÄ›nÃ½ch funkcÃ­ `reversed(...)` a `...reverse()` obrÃ¡tÃ­ seznam a to Â¨in-placeÂ¨.

```python
def reverseInPlace(lst: list):
  for i in range(len(lst)//2):
    lst[i], lst[-1-i] = lst[-1-i], lst[i]
```

Naprogramujte funkci, kterÃ¡ "in-place" seÅ™adÃ­ seznam pomocÃ­ algoritmu [bublinkovÃ©ho Å™azenÃ­](https://cs.wikipedia.org/wiki/Bublinkov%C3%A9_%C5%99azen%C3%A), nebo i jinÃ©ho [Å™adicÃ­ho algoritmu](https://cs.wikipedia.org/wiki/Kategorie:%C5%98adic%C3%AD_algoritmy).

```python
import random
```

```python
def bubbleSort(lst: list):
  sorted = False # run the loop at least once
  while not sorted:
    print(lst)    # trace print
    sorted = True # assumption
    for i in range(len(lst)-1):
      if not lst[i] <= lst[i+1]:
        lst[i],lst[i+1] = lst[i+1],lst[i]
        sorted = False # assumption was wrong, must redo

bubbleSort([random.randint(10,99) for _ in range(18)])
```

```python
def cocktailSort(lst:list):
  def needsSwap(i):
    j = i+1

    if lst[i] <= lst[j]: return False

    lst[i],lst[j] = lst[j],lst[i]
    return True

  start = 0; end = len(lst) - 1

  print(lst)
  while True:
    # forth
    sorted = True
    for i in range(start, end):
      if needsSwap(i): sorted = False

    if sorted:
      break

    print(lst)
    end -= 1

    # back
    sorted = True
    for i in range(end-1, start-1, -1):
      if needsSwap(i): sorted = False

    if sorted:
      break

    print(lst)
    start += 1

lst = list(range(10,20))
random.shuffle(lst)

cocktailSort(lst)
```

```python
def mySort(lst: list):
  ll = len(lst)

  def swap(i,j):
    lst[i],lst[j] = lst[j],lst[i]

  def minIdx(fromI):
    return min(range(fromI,ll), key=lambda i: lst[i])

  print(lst)
  for i in range(ll-1):
    swap(i,minIdx(i))
    print(lst)

lst = list(range(10,20))
random.shuffle(lst)

mySort(lst)
```
